//создания массива предусматривает исполь­зование литерала типа массива
let empty = [];// Массив без элементов
let primes = [2, 3, 5, 7, 11];// Массив с пятью числовыми элементами
let misc = [1.1, true, "а",];
console.log(misc, empty, primes) // Три элемента различных типов плюс хвостовая запятая

//Значения литерала типа массива могут быть произвольными выражениями:
let base = 1024;
let table = [base, base + 1, base + 2, base + 3]
console.log(table, base)

//Литералы типа массивов могут содержать объектные литералы или другие литералы типа массивов:
let b1 = [[1, { х: 1, у: 2 }], [2, { х: 3, у: 4 }]];
console.log(b1)

//Операция распространения
let a = [1, 2, 3];
let b = [0, ...a, 4];
console.log(a, b)
//Операция распространения обеспечивает удобный способ создания копии массива:
let original = [1, 2, 3];
let copy = [...original];
copy[0] = 0;// Модификация копии не приводит к изменению оригинала
original[0]// => 1

//Операция распространения работает с любым итерируемым объектом.
//Итерируемые объекты — такие объекты, по которым выполняет проход цикл for/of ; 
let digits = [..."0123456789ABCDEF"];
console.log(digits)// => ["0",”1","2","3",”4","5”,"б",”7",”8”,"9","А","В","С","D","Е", "F"]

//удаления дублированных элементов из массива
let letters = [..."hello world"];
console.log([...new Set(letters)]) // => ["h","e","1","o"," ","w","r","d"]

//создания массива — применение конструктора Array()
let a2 = new Array();
console.log(a2)// пустой массив

//Вызов с одиночным числовым аргументом, который указывает длину:
let s = new Array(10);
console.log(s)

// указание двух и более элементов массива или одиночного нечисло­вого элемента:
let f = new Array(5, 4, 3, 2, 1, "testing, testing");
console.log(f)

//функция конструктора Array() вызывается с одним числовым аргу­ментом, она использует его как длину массива. 
//Но при вызове с большим коли­чеством числовых аргументов функция конструктора Array() трактует их как
//элементы для создаваемого массива
let r = Array.of() //=>[]; при вызове без аргументов возвращает пустой массив
let t = Array.of(10)// => [10]; при вызове с единственным числовым аргументом способна создавать массивы
let y = Array.of(1, 2, 3)// => [1, 2, 3]
console.log(r, t, y)

//Array.from —  ожидаетв первом аргументе итерируемый или похожий на массив объект и возвращает
//новый массив, который содержит элементы переданного объекта.
let original9 = [1, 2, 3]
let copy8 = Array.from(original9);
console.log(copy8)

//Чтение и запись элементов массива
let l = ["world"];// Начать с одноэлементного массива
let vr = l[0];// Прочитать элемент 0
l[1] = 3.14;// Записать элемент 1
let i = 2;
l[i] = 3;// Записать элемент 2
l[i + 1] = "hello";// Записать элемент 3
l[l[i]] = l[0];// Прочитать элементы 0 и 2, записать элемент 3
console.log(l.length)// 4 элемента

let lp = {};// Создать простой объект
lp[1] = 'первый элемент'// Индексировать его с помощью целого числа
console.log(lp["1"])// => "one"; числовые и строковые имена свойств считаются одинаковыми

//Разреженный массив - элементы которого не имеют непрерыв­ных индексов, начинающихся с 0
let lk = new Array(5);// Элементы отсутствуют, но a.length равно 5
lk = [];// Создает массив без элементов и length = 0
lk[1000] = 0;// Присваивание добавляет один элемент, но устанавливает length в 1001
console.log(lk.length, lk)

//Длина массива
console.log(["a", "b", "с"].length) // => 3: самый высокий индекс равен 2,значение length равно 3

//свойство length в неотрицательное целое число n,тогда любые элементы, чьи индексы больше или равны n, удалятся изМассива:
gh = [1, 2, 3, 4, 5];// Начать с пятиэлементного массива
console.log(gh)
gh.length = 3;// а теперь [1,2,3]
console.log(gh)
gh.length = 0;// Удалить все элементы, а становится []
console.log(gh)
gh.length = 5;// Длина равна 5, но элементы отсутствуют, подобно new Array(5)
console.log(gh)

//Добавление и удаление элементов массива
let fg = [];// Начать с пустого массива
fg[0] = "zero";// И добавить в него элементы
console.log(fg)

// push() для добавления одного и более зна­чений
let rf = [];// Начать с пустого массива
rf.push("zero");// Добавить значение в конец, а = ["zero”]
rf.push("one", "two")// Добавить еще два значения.
console.log(rf)

//удалять элементы массива с помощью операции delete 
let bb = [1, 2, 3];
delete bb[2];// Теперь а не имеет элемента по индексу 2
2 in bb// => false: индекс 2 в массиве не определен
bb.length// => 3: delete не влияет на длину массива

//Итерация по массивам
let arrayLet = [..."Hello world"]; // Массив букв
console.log(arrayLet)
let string = "";
for (let leter of arrayLet) {
    string += leter;
}
console.log(string)// => "Hello world"; мы повторно собрали первоначальный текст

let everyother = "";
for (let [index, letter1] of letters.entries()) {
    if (index % 2 === 0) everyother += letter1; // буквы по четным индексам
}
console.log(everyother) // => "Hlowrd"

//способ итерации по массивам forEach()
let uppercase = "";
letters.forEach(letter => {// Обратите внимание на синтаксис стрелочной функции
    uppercase += letter.toUpperCase();
});
console.log(uppercase) // => "HELLO WORLD"

let vowels = ''
for (let i = 0; i < letters.length; i++) {//Для каждого индекса в массиве
    let letter = letters[i];// Получить элемент по этому индексу
    if (/[aeiou]/.test(letter)) {// Использовать проверку с регулярным выражением
        vowels += letter;// Если гласная буква, то запомнить ее
    }
}
console.log(vowels)// => "еоо"

// Сохранить длину массива в локальной переменной
for (let uy = 0, len = letters.length; uy < len; uy++) {
    // тело цикла остается прежним
    console.log(uy)
}

// Итерация в обратном направлении с конца до начала массива
for (let io = letters.length - 1; io >= 0; io--) {
    // тело цикла остается прежним
    console.log(io)
}

// Пропускать неопределенные и несуществующие элементы
for (let i = 0; i < a.length; i++) {
    if (a[i] === undefined) continue;
    // тело цикла
    console.log(a)
}

//Многомерные массивы

let tabMatrix = new Array(10);// Создать многомерный массив 10 строк таблицы

for (let i = 0; i < tabMatrix.length; i++) {
    tabMatrix[i] = new Array(10);    // Каждая строка имеет 10 столбцов
}
// Инициализировать массив
for (let row = 0; row < tabMatrix.length; row++) {
    for (let col = 0; col < tabMatrix[row].length; col++) {
        tabMatrix[row][col] = row * col;
    }
}
// Использовать многомерный массив для вычисления 5*7
console.log(tabMatrix[5][7])// => 35

// Методы итераторов для массивов

//forEach () проходит по массиву, вызывая для каждого элемента ука­занную вами функцию
let data = [1, 2, 3, 4, 5], sum = 0
// Вычислить сумму элементов массива
let sumData = data.forEach(value => { sum += value; });// sum == 15
console.log(sumData)
// А теперь инкрементировать каждый элемент массива
let fgh = data.forEach(function (v, i, a) { a[i] = v + 1; })//data== [2,3,4,5,6]
console.log(fgh)

//map () передает каждый элемент массива, на котором он вызван, ука­занной вами функции и возвращает массив со значениями
let asd = [1, 2, 3]
console.log(asd.map(x => x * x)) // => [1, 4, 9]: функция принимает на входе х и возвращает х*х

//filter() возвращает массив, содержащий подмножество элементов массива, на котором он был вызван
let filterR = [5, 4, 3, 2, 1];
console.log(filterR.filter(х => х < 3))// => [2, 1]; значения меньше 3
console.log(filterR.filter((x, i) => i % 2 === 0))// => [5, 3, 1]; все остальные значения

//устранения брешей и удаления элементов undefined и n u ll вы може­те применить filter() следующим образом:
let dw = [1, 2, 3, 4, null, 6]
console.log(dw)
dw = dw.filter(х => х !== undefined && х !== null);
console.log(dw)

//find() и findlndex()проходят по массиву в поиске элементов, для которых ваша функция предиката
// и останавливают итерацию, как только предикат впервые находит элемент.
/*
 let iop = [1, 2, 3, 4, 5];
iop.findlndex(x >= x == 3)// => 2; значение 3 находится по индексу 2
iop.findlndex(x >= x < 0)// => - 1 ; отрицательных чисел в массиве нет
iop.find(x >= x % 5 === 0)// => 5: число, кратное 5
iop.find(x >= x % 7 === 0)// => undefined: числа, кратные 7,в массиве отсутствуют
*/

//every () и some () являются предикатами массивов: они применяют указанную вами функцию предиката
// к элементам массива, после чего возвраща­ют true или false 
let dudu = [1, 2, 3, 4, 5];
console.log(dudu.every(x => x < 10))// => true: все значения < 10
console.log(dudu.every(x => x % 2 === 0))// => false: не все значение четные

//reduce() И reduceRight() объединяют элементы массива, исполь­зуя указанную вами функцию, для получения единственного значения
let bgt = [1, 2, 3, 4, 5]
bgt.reduce((х, у) => х + у, 0)// => 15; сумма значений
bgt.reduce((х, у) => х * у, 1)// => 120; произведение значений
bgt.reduce((х, у) => (х > у) ? х : у)// => 5; наибольшее из значений

// flat() создает и возвращает новый массив, содержащий теже самые элементы, что и массив,
// на котором он вызывался, но любые элемен­ты, являющиеся массивами, 
//в результирующем массиве будут “выровненными”.
let oko = [1, [2, 3]].flat()// => [1, 2, 3]

//concat() создает и возвращает новый массив, содержащий элементы исходного массива,
// за которыми следуют все аргументы, переданные concat ()
let cdr = [1, 2, 3, 4, 5, 6]
cdr.concat(7, 8)//1,2,3,4,6,7,8
let dfr = cdr.concat([8, 9], [345, 345])//массивы выравниваются
console.log(dfr)
let kokoko = cdr.concat(4, [5, [6, 7]])
console.log(kokoko)
console.log(cdr)//исходный массив остается немодифицированным

//push () добавляет один или большее количество элемен­тов в конец массива и возвращает новую длину массива.
//pop()удаляет последний элемент массива, де­крементирует длину массива и возвращает значение, которое было удалено
let stack = [];// stack == [] •
stack.push(1, 2);// stack == [1,2];
stack.pop();// stack == 11 ]; возвращается 2
stack.push(3);// stack == [1,3]
stack.pop();// stack == [ 1]; возвращается 3
stack.push([4, 5]);// stack == [1,[4,5]]
stack.pop()// stack == [1]; возвращается [4,5]
stack.pop();// stack == [ ]; возвращается 1

// unshift() и shift() ведут себя во многом похоже на push () и pop ()
// за исключением того, что они вставляют и удаляют элементы с начала,а не с конца массива.

//slice() возвращает срез, или подмассив, заданного массива. 
let as = [1, 2, 3, 4, 5];
console.log(
    as.slice(0, 3),// Возвращается [1 ,2 ,3 ]
    as.slice(3),// Возвращается [4,5]
    as.slice(l, - l),// Возвращается [2 ,3 ,4 ]
    as.slice(- 3 / - 2)// Возвращается [3]
)

// splice() — это универсальный метод для вставки или удаления элементов из массива
//модифицирует массив на котором вызван
// Первый аргумент splic e() задает позицию в массиве, где начинается вставка
// и/или удаление. Второй аргумент указывает количество элементов, которые тре­
// буется удалить из (отщепить от) массива. 
let ase = [1, 2, 3, 4, 5, 6, 7, 8];
console.log(
    ase.splice(4),// => [5,6,7,8]; а теперь [1,2,3,4]
    ase.splice(1, 2),// => [2,3]; а теперь [1,4]
    ase.splice(1, 1)// => [4]; а теперь [1]
)

// Первый аргумент splice() задает позицию в массиве, где начинается вставка
// и/или удаление. Второй аргумент указывает количество элементов, которые тре­
// буется удалить из (отщепить от) массива. 

let lop = [1, 2, 3, 4, 5];
console.log(
    lop.splice(2, 0, "а", "b"),// => []; а теперь [1,2,"а","Ь",3,4,5]
    lop.splice(2, 2, [1, 2], 3) // => ["a","b"]; а теперь [1,2,[1,2],3,3,4,5]
)

// fill() устанавливает элементы массива или среза массива в указан­ное значение
let jil = new Array(5);// Начать с массива без элементов длиной 5
console.log(
    jil.fill(0),// = > [0,0,0,0,0]; заполнить массив нулями
    jil.fill(9, l),// => [0,9,9,9,9]; заполнить значениями 9,начиная с индекса 1
    jil.fill(8, 2, -1)// => [0,9,8,8,9]; заполнить значениями 8 по индексам 2, 3
)

//Метод indexOf () производит поиск в массиве сначала до конца, а метод lastlndexOf() — с конца до начала:
let yhu = [0, 1, 2, 1, 0];
console.log(
    yhu.indexOf(1),// => 1: а [ 1 ] равно 1
    yhu.lastIndexOf(1),// => 3: а [3] равно 1
    yhu.indexOf(3)// => -1: нет элементов со значением 3
)

//includes() из ES2016 принимает единственный аргумент и возвра­щает true,
// если массив содержит значение аргумента, или false в противном случае
let vbh = [1, true, 3, NaN];
console.log(
    vbh.includes(true),// => true
    vbh.includes(2),// => false
    vbh.includes(NaN),// => true
    vbh.indexOf(NaN)// => -1; indexOf не может отыскивать NaN
)

//sort() сортирует элементы массива на месте и возвращает отсор­тированный массив
let ghut = ["banana", "cherry", "apple"];
console.log(
    ghut.sort()// [ "apple", "banana", "cherry"]
)

let aa = [33, 4, 1111, 222];
console.log(
    aa.sort(),// а == [1111, 222, 33, 4]; алфавитный порядок
    aa.sort(function (aa, bb) { // Передать функцию сравнения
        return aa - bb; //Возвращает число <0,0 или > 0 в зависимости от порядка
    }),
    //а == [4, 33, 222, 1111]; числовой порядок
    aa.sort((aa, bb) => bb - aa) //а == [1111, 222, 33, 4]; обратный числовой порядок
)

let aaa = ["ant", "Bug", "cat", "Dog"];
console.log(
    aaa.sort(),// a == ["Bug", "Dog", "ant", "cat"]; сортировка,чувствительная к регистру
    aaa.sort(function (s, t) {
        let aaa = s.toLowerCase();
        let bbb = t.toLowerCase();
        if (aaa < bbb) return -1;
        if (aaa > bbb) return 1;
        return 0;
    })// a == ["ant","Bug","cat","Dog"]; сортировка, нечувствительная к регистру
)

//reverse () изменяет на противоположный порядок следования эле­ментов в массиве и возвращает обращенный массив.
let sdsd = [1, 2, 3];
console.log(
    sdsd.reverse()// а == [3,2,1]
)

//join() преобразует все элементы массива в строки и выполняет ихконкатенацию, возвращая результирующую строку
let aadd = [1, 2, 3]
let bbbv = new Array(10)// Массив с длиной 10 без элементов
console.log(
    aadd.join(),// => ”1,2,3”
    aadd.join(" "),// => "1 2 3"
    aadd.join(""),// => ”123”

    bbbv.join("-")//=> ”---------”: строка из 9 дефисов
)
//toString(). Для массива онработает подобно методу join(), вызываемому без аргументов:
let sadsad = [1, 2, 3].toString()// => "1,2,3"
console.log(sadsad)
let sadsadas = ["а", "Ь", "с"].toString() // => ”а,Ь,с”
console.log(sadsadas)
let ghte = [1, [2, "с"]].toString()// => ”1,2,с”
console.log(ghte)

//toLocaleString() преобразует каждый элемент массива в строку, после чего выполняет конкатенацию результиру­ющих строк
// с использованием специфической к локали  строки разделителя.
let der = new Date();
let ner = der.toLocaleString()
console.log(der)

// Объекты, похожие на массивы
let abject = {}; // Начать с обыкновенного пустого объекта
let ii = 0;// Добавить свойства, чтобы сделать его "похожим на массив"
while (ii < 10) {
    abject[ii] = ii * ii;
    ii++;
    console.log(ii)
}
console.log(abject.length = ii)
// Выполнить итерацию по нему, как если бы он был настоящим массивом
let total = 0;
for (let ii = 0; ii < abject.length; ii++) {
    total += abject[ii];
    console.log(ii)
}
console.log(total)

// Определяет, является ли о объектом, похожим на массив.
// Строки и функции имеют числовые свойства length, но исключаются
// проверкой typeof. В коде JavaScript на стороне клиента текстовые
// узлы DOM имеют числовое свойство length, и может понадобиться их
// исключить с помощью дополнительной проверки o.nodeType !== 3.
function isArrayLike(abject) {
    if (abject && // abject - не null, undefined и т.д.
        typeof abject === "object" && // abject - объект
        Number.isFinite(abject.length) &&// abject.length - конечное число
        abject.length >= 0 &&// abject.length - неотрицательное
        Number.isInteger(abject.length) && // abject.length - целое число
        abject.length < 4294967295) { // abject.length < 2^32 - 1
        console.log(true)// Тогда объект abject похож на массив
    } else { 
        console.log(false)// Иначе объект abject не похож на массив
    }
}
isArrayLike()